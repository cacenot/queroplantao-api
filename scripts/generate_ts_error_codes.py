#!/usr/bin/env python3
"""
Generate TypeScript error codes and messages from Python.

This script reads error codes from the backend and generates
TypeScript constants with PT-BR error messages.

Usage:
    uv run python scripts/generate_ts_error_codes.py
"""

from __future__ import annotations

import ast
from dataclasses import dataclass
from pathlib import Path
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from collections.abc import Iterator

# Paths
PROJECT_ROOT = Path(__file__).parent.parent
OUTPUT_DIR = PROJECT_ROOT / "packages" / "api-client" / "src" / "i18n"
ERROR_CODES_FILE = PROJECT_ROOT / "src" / "app" / "constants" / "error_codes.py"
I18N_FILE = PROJECT_ROOT / "src" / "app" / "i18n" / "locales" / "pt_br.py"


@dataclass
class ErrorCode:
    """Represents an error code constant."""

    name: str
    value: str
    category: str


def parse_error_codes() -> Iterator[ErrorCode]:
    """Parse error codes from the error_codes.py file."""
    if not ERROR_CODES_FILE.exists():
        print(f"  âš ï¸  Error codes file not found: {ERROR_CODES_FILE}")
        return

    source = ERROR_CODES_FILE.read_text()
    tree = ast.parse(source)

    for node in ast.walk(tree):
        if not isinstance(node, ast.ClassDef):
            continue

        # Check if it's a StrEnum subclass (error codes pattern)
        is_str_enum = any(
            (isinstance(base, ast.Name) and base.id == "StrEnum") for base in node.bases
        )

        if not is_str_enum:
            continue

        class_name = node.name
        # Extract category from class name (e.g., "AuthErrorCodes" -> "Auth")
        category = class_name.replace("ErrorCodes", "")

        for item in node.body:
            if not isinstance(item, ast.Assign):
                continue

            for target in item.targets:
                if not isinstance(target, ast.Name):
                    continue

                if target.id.startswith("_"):
                    continue

                if isinstance(item.value, ast.Constant):
                    yield ErrorCode(
                        name=target.id,
                        value=str(item.value.value),
                        category=category,
                    )


def parse_i18n_messages() -> dict[str, str]:
    """
    Parse i18n messages from pt_br.py.

    Returns a dict mapping message keys to PT-BR translations.
    The pt_br.py file uses enum members as keys (e.g., AuthMessages.MISSING_TOKEN).
    """
    messages: dict[str, str] = {}

    if not I18N_FILE.exists():
        print(f"  âš ï¸  i18n file not found: {I18N_FILE}")
        return messages

    # Read the file and extract key-value pairs using regex
    # Format: EnumClass.MEMBER_NAME: "translation"
    import re

    content = I18N_FILE.read_text()

    # Pattern matches: SomeMessages.KEY_NAME: "translation" or (multiline strings)
    pattern = r'(\w+Messages)\.(\w+):\s*(?:"([^"]+)"|\'([^\']+)\'|\([\s\S]*?"([^"]+)"[\s\S]*?\))'
    matches = re.findall(pattern, content)

    for match in matches:
        enum_class, member_name, val1, val2, val3 = match
        value = val1 or val2 or val3
        if value:
            # Use member name as key (matches error code name pattern)
            messages[member_name] = value

    return messages


def generate_error_codes_ts(codes: list[ErrorCode]) -> str:
    """Generate TypeScript error codes file."""
    lines: list[str] = [
        "/**",
        " * API Error Codes.",
        " *",
        " * AUTO-GENERATED by scripts/generate_ts_error_codes.py",
        " * DO NOT EDIT MANUALLY",
        " */",
        "",
        "/**",
        " * All error codes as a const object for type-safe access.",
        " * Keys are prefixed with category to avoid duplicates (e.g., AUTH_USER_NOT_FOUND).",
        " */",
        "export const ErrorCodes = {",
    ]

    # Group by category
    categories: dict[str, list[ErrorCode]] = {}
    for code in codes:
        categories.setdefault(code.category, []).append(code)

    for category, cat_codes in sorted(categories.items()):
        lines.append(f"  // {category} errors")
        for code in cat_codes:
            # Use category prefix to make keys unique
            key = f"{category.upper()}_{code.name}"
            lines.append(f'  {key}: "{code.value}",')
        lines.append("")

    lines.append("} as const;")
    lines.append("")
    lines.append(
        "export type ErrorCode = (typeof ErrorCodes)[keyof typeof ErrorCodes];"
    )

    return "\n".join(lines)


def generate_error_messages_ts(codes: list[ErrorCode], messages: dict[str, str]) -> str:
    """Generate TypeScript error messages file."""
    lines: list[str] = [
        "/**",
        " * PT-BR Error Messages for each error code.",
        " *",
        " * AUTO-GENERATED by scripts/generate_ts_error_codes.py",
        " * DO NOT EDIT MANUALLY",
        " */",
        "",
        "import { ErrorCodes } from './error-codes';",
        "",
        "/**",
        " * PT-BR messages for each error code.",
        " * Use these to display user-friendly error messages.",
        " */",
        "export const ErrorMessages: Record<string, string> = {",
    ]

    # Map error codes to messages
    for code in codes:
        # Use category prefix to match ErrorCodes keys
        key = f"{code.category.upper()}_{code.name}"
        # Try to find matching message
        message = messages.get(code.name)
        if message:
            # Escape quotes
            message = message.replace('"', '\\"')
            lines.append(f'  [ErrorCodes.{key}]: "{message}",')
        else:
            # Fallback to humanized error code name
            humanized = code.name.replace("_", " ").title()
            lines.append(f'  [ErrorCodes.{key}]: "{humanized}",')

    lines.append("};")
    lines.append("")
    lines.append("/**")
    lines.append(" * Get the PT-BR message for an error code.")
    lines.append(" * Returns a fallback message if the code is unknown.")
    lines.append(" */")
    lines.append("export function getErrorMessage(code: string): string {")
    lines.append('  return ErrorMessages[code] ?? "Ocorreu um erro inesperado";')
    lines.append("}")

    return "\n".join(lines)


def generate_index_ts() -> str:
    """Generate the main index.ts file."""
    return """/**
 * i18n utilities - error codes and messages.
 *
 * AUTO-GENERATED by scripts/generate_ts_error_codes.py
 * DO NOT EDIT MANUALLY
 */

export * from "./error-codes";
export * from "./error-messages";
"""


def main() -> None:
    """Main entry point."""
    print("ğŸ”„ Generating TypeScript error codes and messages...")

    # Ensure output directory exists
    OUTPUT_DIR.mkdir(parents=True, exist_ok=True)

    # Parse error codes
    codes = list(parse_error_codes())
    print(f"  ğŸ“‹ Found {len(codes)} error codes")

    # Parse i18n messages
    messages = parse_i18n_messages()
    print(f"  ğŸŒ Found {len(messages)} i18n messages")

    # Generate error codes file
    error_codes_content = generate_error_codes_ts(codes)
    error_codes_file = OUTPUT_DIR / "error-codes.ts"
    error_codes_file.write_text(error_codes_content)
    print(f"  âœ… Generated {error_codes_file.name}")

    # Generate error messages file
    error_messages_content = generate_error_messages_ts(codes, messages)
    error_messages_file = OUTPUT_DIR / "error-messages.ts"
    error_messages_file.write_text(error_messages_content)
    print(f"  âœ… Generated {error_messages_file.name}")

    # Generate index file
    index_content = generate_index_ts()
    index_file = OUTPUT_DIR / "index.ts"
    index_file.write_text(index_content)
    print(f"  ğŸ“¦ Generated {index_file.name}")

    print("âœ… Done!")


if __name__ == "__main__":
    main()
