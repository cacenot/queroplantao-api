/**
 * Generated by orval v7.20.0 üç∫
 * Do not edit manually.
 * Quero Plant√£o API
 * REST API para gest√£o de plant√µes m√©dicos
 * OpenAPI spec version: 0.1.0
 */
import { useMutation } from "@tanstack/react-query";
import type {
  MutationFunction,
  QueryClient,
  UseMutationOptions,
  UseMutationResult,
} from "@tanstack/react-query";

import type {
  BodyUploadDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdUploadPost,
  ConfigureDocumentsRequest,
  DocumentUploadStepResponse,
  ErrorResponse,
  HTTPValidationError,
  ReuseDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdReusePostParams,
  ReviewDocumentRequest,
  ScreeningDocumentResponse,
} from "../../models/index.js";

import { customFetch } from "../../custom-fetch.js";

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * Configura a lista de documentos necess√°rios para a triagem. Transiciona o step de PENDING para IN_PROGRESS.
 * @summary Configurar documentos
 */
export type configureDocumentsApiV1ScreeningsScreeningIdStepsDocumentUploadConfigurePostResponse201 =
  {
    data: DocumentUploadStepResponse;
    status: 201;
  };

export type configureDocumentsApiV1ScreeningsScreeningIdStepsDocumentUploadConfigurePostResponse422 =
  {
    data: HTTPValidationError;
    status: 422;
  };

export type configureDocumentsApiV1ScreeningsScreeningIdStepsDocumentUploadConfigurePostResponseSuccess =
  configureDocumentsApiV1ScreeningsScreeningIdStepsDocumentUploadConfigurePostResponse201 & {
    headers: Headers;
  };
export type configureDocumentsApiV1ScreeningsScreeningIdStepsDocumentUploadConfigurePostResponseError =
  configureDocumentsApiV1ScreeningsScreeningIdStepsDocumentUploadConfigurePostResponse422 & {
    headers: Headers;
  };

export type configureDocumentsApiV1ScreeningsScreeningIdStepsDocumentUploadConfigurePostResponse =

    | configureDocumentsApiV1ScreeningsScreeningIdStepsDocumentUploadConfigurePostResponseSuccess
    | configureDocumentsApiV1ScreeningsScreeningIdStepsDocumentUploadConfigurePostResponseError;

export const getConfigureDocumentsApiV1ScreeningsScreeningIdStepsDocumentUploadConfigurePostUrl =
  (screeningId: string) => {
    return `/api/v1/screenings/${screeningId}/steps/document-upload/configure`;
  };

export const configureDocumentsApiV1ScreeningsScreeningIdStepsDocumentUploadConfigurePost =
  async (
    screeningId: string,
    configureDocumentsRequest: ConfigureDocumentsRequest,
    options?: RequestInit,
  ): Promise<configureDocumentsApiV1ScreeningsScreeningIdStepsDocumentUploadConfigurePostResponse> => {
    return customFetch<configureDocumentsApiV1ScreeningsScreeningIdStepsDocumentUploadConfigurePostResponse>(
      getConfigureDocumentsApiV1ScreeningsScreeningIdStepsDocumentUploadConfigurePostUrl(
        screeningId,
      ),
      {
        ...options,
        method: "POST",
        headers: { "Content-Type": "application/json", ...options?.headers },
        body: JSON.stringify(configureDocumentsRequest),
      },
    );
  };

export const getConfigureDocumentsApiV1ScreeningsScreeningIdStepsDocumentUploadConfigurePostMutationOptions =
  <TError = HTTPValidationError, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<
          typeof configureDocumentsApiV1ScreeningsScreeningIdStepsDocumentUploadConfigurePost
        >
      >,
      TError,
      { screeningId: string; data: ConfigureDocumentsRequest },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  }): UseMutationOptions<
    Awaited<
      ReturnType<
        typeof configureDocumentsApiV1ScreeningsScreeningIdStepsDocumentUploadConfigurePost
      >
    >,
    TError,
    { screeningId: string; data: ConfigureDocumentsRequest },
    TContext
  > => {
    const mutationKey = [
      "configureDocumentsApiV1ScreeningsScreeningIdStepsDocumentUploadConfigurePost",
    ];
    const { mutation: mutationOptions, request: requestOptions } = options
      ? options.mutation &&
        "mutationKey" in options.mutation &&
        options.mutation.mutationKey
        ? options
        : { ...options, mutation: { ...options.mutation, mutationKey } }
      : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<
          typeof configureDocumentsApiV1ScreeningsScreeningIdStepsDocumentUploadConfigurePost
        >
      >,
      { screeningId: string; data: ConfigureDocumentsRequest }
    > = (props) => {
      const { screeningId, data } = props ?? {};

      return configureDocumentsApiV1ScreeningsScreeningIdStepsDocumentUploadConfigurePost(
        screeningId,
        data,
        requestOptions,
      );
    };

    return { mutationFn, ...mutationOptions };
  };

export type ConfigureDocumentsApiV1ScreeningsScreeningIdStepsDocumentUploadConfigurePostMutationResult =
  NonNullable<
    Awaited<
      ReturnType<
        typeof configureDocumentsApiV1ScreeningsScreeningIdStepsDocumentUploadConfigurePost
      >
    >
  >;
export type ConfigureDocumentsApiV1ScreeningsScreeningIdStepsDocumentUploadConfigurePostMutationBody =
  ConfigureDocumentsRequest;
export type ConfigureDocumentsApiV1ScreeningsScreeningIdStepsDocumentUploadConfigurePostMutationError =
  HTTPValidationError;

/**
 * @summary Configurar documentos
 */
export const useConfigureDocumentsApiV1ScreeningsScreeningIdStepsDocumentUploadConfigurePost =
  <TError = HTTPValidationError, TContext = unknown>(
    options?: {
      mutation?: UseMutationOptions<
        Awaited<
          ReturnType<
            typeof configureDocumentsApiV1ScreeningsScreeningIdStepsDocumentUploadConfigurePost
          >
        >,
        TError,
        { screeningId: string; data: ConfigureDocumentsRequest },
        TContext
      >;
      request?: SecondParameter<typeof customFetch>;
    },
    queryClient?: QueryClient,
  ): UseMutationResult<
    Awaited<
      ReturnType<
        typeof configureDocumentsApiV1ScreeningsScreeningIdStepsDocumentUploadConfigurePost
      >
    >,
    TError,
    { screeningId: string; data: ConfigureDocumentsRequest },
    TContext
  > => {
    const mutationOptions =
      getConfigureDocumentsApiV1ScreeningsScreeningIdStepsDocumentUploadConfigurePostMutationOptions(
        options,
      );

    return useMutation(mutationOptions, queryClient);
  };
/**
 * Faz upload de um documento para a triagem. O arquivo √© enviado via multipart/form-data e o backend faz upload para o Firebase Storage, cria o ProfessionalDocument (is_pending=True) e o vincula ao ScreeningDocument, inferindo qualification_id e specialty_id com base na categoria do documento.
 * @summary Upload de documento
 */
export type uploadDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdUploadPostResponse200 =
  {
    data: ScreeningDocumentResponse;
    status: 200;
  };

export type uploadDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdUploadPostResponse422 =
  {
    data: HTTPValidationError;
    status: 422;
  };

export type uploadDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdUploadPostResponseSuccess =
  uploadDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdUploadPostResponse200 & {
    headers: Headers;
  };
export type uploadDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdUploadPostResponseError =
  uploadDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdUploadPostResponse422 & {
    headers: Headers;
  };

export type uploadDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdUploadPostResponse =

    | uploadDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdUploadPostResponseSuccess
    | uploadDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdUploadPostResponseError;

export const getUploadDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdUploadPostUrl =
  (screeningId: string, documentId: string) => {
    return `/api/v1/screenings/${screeningId}/documents/${documentId}/upload`;
  };

export const uploadDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdUploadPost =
  async (
    screeningId: string,
    documentId: string,
    bodyUploadDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdUploadPost: BodyUploadDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdUploadPost,
    options?: RequestInit,
  ): Promise<uploadDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdUploadPostResponse> => {
    const formData = new FormData();
    formData.append(
      `file`,
      bodyUploadDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdUploadPost.file,
    );
    if (
      bodyUploadDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdUploadPost.expires_at !==
        undefined &&
      bodyUploadDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdUploadPost.expires_at !==
        null
    ) {
      formData.append(
        `expires_at`,
        bodyUploadDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdUploadPost.expires_at,
      );
    }
    if (
      bodyUploadDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdUploadPost.notes !==
        undefined &&
      bodyUploadDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdUploadPost.notes !==
        null
    ) {
      formData.append(
        `notes`,
        bodyUploadDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdUploadPost.notes,
      );
    }

    return customFetch<uploadDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdUploadPostResponse>(
      getUploadDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdUploadPostUrl(
        screeningId,
        documentId,
      ),
      {
        ...options,
        method: "POST",
        body: formData,
      },
    );
  };

export const getUploadDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdUploadPostMutationOptions =
  <TError = HTTPValidationError, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<
          typeof uploadDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdUploadPost
        >
      >,
      TError,
      {
        screeningId: string;
        documentId: string;
        data: BodyUploadDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdUploadPost;
      },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  }): UseMutationOptions<
    Awaited<
      ReturnType<
        typeof uploadDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdUploadPost
      >
    >,
    TError,
    {
      screeningId: string;
      documentId: string;
      data: BodyUploadDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdUploadPost;
    },
    TContext
  > => {
    const mutationKey = [
      "uploadDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdUploadPost",
    ];
    const { mutation: mutationOptions, request: requestOptions } = options
      ? options.mutation &&
        "mutationKey" in options.mutation &&
        options.mutation.mutationKey
        ? options
        : { ...options, mutation: { ...options.mutation, mutationKey } }
      : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<
          typeof uploadDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdUploadPost
        >
      >,
      {
        screeningId: string;
        documentId: string;
        data: BodyUploadDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdUploadPost;
      }
    > = (props) => {
      const { screeningId, documentId, data } = props ?? {};

      return uploadDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdUploadPost(
        screeningId,
        documentId,
        data,
        requestOptions,
      );
    };

    return { mutationFn, ...mutationOptions };
  };

export type UploadDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdUploadPostMutationResult =
  NonNullable<
    Awaited<
      ReturnType<
        typeof uploadDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdUploadPost
      >
    >
  >;
export type UploadDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdUploadPostMutationBody =
  BodyUploadDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdUploadPost;
export type UploadDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdUploadPostMutationError =
  HTTPValidationError;

/**
 * @summary Upload de documento
 */
export const useUploadDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdUploadPost =
  <TError = HTTPValidationError, TContext = unknown>(
    options?: {
      mutation?: UseMutationOptions<
        Awaited<
          ReturnType<
            typeof uploadDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdUploadPost
          >
        >,
        TError,
        {
          screeningId: string;
          documentId: string;
          data: BodyUploadDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdUploadPost;
        },
        TContext
      >;
      request?: SecondParameter<typeof customFetch>;
    },
    queryClient?: QueryClient,
  ): UseMutationResult<
    Awaited<
      ReturnType<
        typeof uploadDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdUploadPost
      >
    >,
    TError,
    {
      screeningId: string;
      documentId: string;
      data: BodyUploadDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdUploadPost;
    },
    TContext
  > => {
    const mutationOptions =
      getUploadDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdUploadPostMutationOptions(
        options,
      );

    return useMutation(mutationOptions, queryClient);
  };
/**
 * Reutiliza um documento j√° aprovado de triagens anteriores. Apenas documentos que n√£o est√£o pendentes (is_pending=False) podem ser reutilizados. O documento reutilizado recebe status PENDING_REVIEW e segue para revis√£o.
 * @summary Reutilizar documento existente
 */
export type reuseDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdReusePostResponse200 =
  {
    data: ScreeningDocumentResponse;
    status: 200;
  };

export type reuseDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdReusePostResponse404 =
  {
    data: ErrorResponse;
    status: 404;
  };

export type reuseDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdReusePostResponse422 =
  {
    data: ErrorResponse;
    status: 422;
  };

export type reuseDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdReusePostResponseSuccess =
  reuseDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdReusePostResponse200 & {
    headers: Headers;
  };
export type reuseDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdReusePostResponseError =
  (
    | reuseDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdReusePostResponse404
    | reuseDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdReusePostResponse422
  ) & {
    headers: Headers;
  };

export type reuseDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdReusePostResponse =

    | reuseDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdReusePostResponseSuccess
    | reuseDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdReusePostResponseError;

export const getReuseDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdReusePostUrl =
  (
    screeningId: string,
    documentId: string,
    params: ReuseDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdReusePostParams,
  ) => {
    const normalizedParams = new URLSearchParams();

    Object.entries(params || {}).forEach(([key, value]) => {
      if (value !== undefined) {
        normalizedParams.append(
          key,
          value === null ? "null" : value.toString(),
        );
      }
    });

    const stringifiedParams = normalizedParams.toString();

    return stringifiedParams.length > 0
      ? `/api/v1/screenings/${screeningId}/documents/${documentId}/reuse?${stringifiedParams}`
      : `/api/v1/screenings/${screeningId}/documents/${documentId}/reuse`;
  };

export const reuseDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdReusePost =
  async (
    screeningId: string,
    documentId: string,
    params: ReuseDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdReusePostParams,
    options?: RequestInit,
  ): Promise<reuseDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdReusePostResponse> => {
    return customFetch<reuseDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdReusePostResponse>(
      getReuseDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdReusePostUrl(
        screeningId,
        documentId,
        params,
      ),
      {
        ...options,
        method: "POST",
      },
    );
  };

export const getReuseDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdReusePostMutationOptions =
  <TError = ErrorResponse, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<
          typeof reuseDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdReusePost
        >
      >,
      TError,
      {
        screeningId: string;
        documentId: string;
        params: ReuseDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdReusePostParams;
      },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  }): UseMutationOptions<
    Awaited<
      ReturnType<
        typeof reuseDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdReusePost
      >
    >,
    TError,
    {
      screeningId: string;
      documentId: string;
      params: ReuseDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdReusePostParams;
    },
    TContext
  > => {
    const mutationKey = [
      "reuseDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdReusePost",
    ];
    const { mutation: mutationOptions, request: requestOptions } = options
      ? options.mutation &&
        "mutationKey" in options.mutation &&
        options.mutation.mutationKey
        ? options
        : { ...options, mutation: { ...options.mutation, mutationKey } }
      : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<
          typeof reuseDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdReusePost
        >
      >,
      {
        screeningId: string;
        documentId: string;
        params: ReuseDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdReusePostParams;
      }
    > = (props) => {
      const { screeningId, documentId, params } = props ?? {};

      return reuseDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdReusePost(
        screeningId,
        documentId,
        params,
        requestOptions,
      );
    };

    return { mutationFn, ...mutationOptions };
  };

export type ReuseDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdReusePostMutationResult =
  NonNullable<
    Awaited<
      ReturnType<
        typeof reuseDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdReusePost
      >
    >
  >;

export type ReuseDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdReusePostMutationError =
  ErrorResponse;

/**
 * @summary Reutilizar documento existente
 */
export const useReuseDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdReusePost =
  <TError = ErrorResponse, TContext = unknown>(
    options?: {
      mutation?: UseMutationOptions<
        Awaited<
          ReturnType<
            typeof reuseDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdReusePost
          >
        >,
        TError,
        {
          screeningId: string;
          documentId: string;
          params: ReuseDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdReusePostParams;
        },
        TContext
      >;
      request?: SecondParameter<typeof customFetch>;
    },
    queryClient?: QueryClient,
  ): UseMutationResult<
    Awaited<
      ReturnType<
        typeof reuseDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdReusePost
      >
    >,
    TError,
    {
      screeningId: string;
      documentId: string;
      params: ReuseDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdReusePostParams;
    },
    TContext
  > => {
    const mutationOptions =
      getReuseDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdReusePostMutationOptions(
        options,
      );

    return useMutation(mutationOptions, queryClient);
  };
/**
 * Revisa um documento individual. Define como APPROVED ou CORRECTION_NEEDED (com motivo).
 * @summary Revisar documento
 */
export type reviewDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdReviewPostResponse200 =
  {
    data: ScreeningDocumentResponse;
    status: 200;
  };

export type reviewDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdReviewPostResponse422 =
  {
    data: HTTPValidationError;
    status: 422;
  };

export type reviewDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdReviewPostResponseSuccess =
  reviewDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdReviewPostResponse200 & {
    headers: Headers;
  };
export type reviewDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdReviewPostResponseError =
  reviewDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdReviewPostResponse422 & {
    headers: Headers;
  };

export type reviewDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdReviewPostResponse =

    | reviewDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdReviewPostResponseSuccess
    | reviewDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdReviewPostResponseError;

export const getReviewDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdReviewPostUrl =
  (screeningId: string, documentId: string) => {
    return `/api/v1/screenings/${screeningId}/documents/${documentId}/review`;
  };

export const reviewDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdReviewPost =
  async (
    screeningId: string,
    documentId: string,
    reviewDocumentRequest: ReviewDocumentRequest,
    options?: RequestInit,
  ): Promise<reviewDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdReviewPostResponse> => {
    return customFetch<reviewDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdReviewPostResponse>(
      getReviewDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdReviewPostUrl(
        screeningId,
        documentId,
      ),
      {
        ...options,
        method: "POST",
        headers: { "Content-Type": "application/json", ...options?.headers },
        body: JSON.stringify(reviewDocumentRequest),
      },
    );
  };

export const getReviewDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdReviewPostMutationOptions =
  <TError = HTTPValidationError, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<
          typeof reviewDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdReviewPost
        >
      >,
      TError,
      { screeningId: string; documentId: string; data: ReviewDocumentRequest },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  }): UseMutationOptions<
    Awaited<
      ReturnType<
        typeof reviewDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdReviewPost
      >
    >,
    TError,
    { screeningId: string; documentId: string; data: ReviewDocumentRequest },
    TContext
  > => {
    const mutationKey = [
      "reviewDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdReviewPost",
    ];
    const { mutation: mutationOptions, request: requestOptions } = options
      ? options.mutation &&
        "mutationKey" in options.mutation &&
        options.mutation.mutationKey
        ? options
        : { ...options, mutation: { ...options.mutation, mutationKey } }
      : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<
          typeof reviewDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdReviewPost
        >
      >,
      { screeningId: string; documentId: string; data: ReviewDocumentRequest }
    > = (props) => {
      const { screeningId, documentId, data } = props ?? {};

      return reviewDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdReviewPost(
        screeningId,
        documentId,
        data,
        requestOptions,
      );
    };

    return { mutationFn, ...mutationOptions };
  };

export type ReviewDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdReviewPostMutationResult =
  NonNullable<
    Awaited<
      ReturnType<
        typeof reviewDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdReviewPost
      >
    >
  >;
export type ReviewDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdReviewPostMutationBody =
  ReviewDocumentRequest;
export type ReviewDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdReviewPostMutationError =
  HTTPValidationError;

/**
 * @summary Revisar documento
 */
export const useReviewDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdReviewPost =
  <TError = HTTPValidationError, TContext = unknown>(
    options?: {
      mutation?: UseMutationOptions<
        Awaited<
          ReturnType<
            typeof reviewDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdReviewPost
          >
        >,
        TError,
        {
          screeningId: string;
          documentId: string;
          data: ReviewDocumentRequest;
        },
        TContext
      >;
      request?: SecondParameter<typeof customFetch>;
    },
    queryClient?: QueryClient,
  ): UseMutationResult<
    Awaited<
      ReturnType<
        typeof reviewDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdReviewPost
      >
    >,
    TError,
    { screeningId: string; documentId: string; data: ReviewDocumentRequest },
    TContext
  > => {
    const mutationOptions =
      getReviewDocumentApiV1ScreeningsScreeningIdDocumentsDocumentIdReviewPostMutationOptions(
        options,
      );

    return useMutation(mutationOptions, queryClient);
  };
